/*
 _____ _    _  _____ ______ _____   _____  _____   ____  ______ _____ _      ______  _____
 |_   _| |  | |/ ____|  ____|  __ \ |  __ \|  __ \ / __ \|  ____|_   _| |    |  ____|/ ____|
 | | | |  | | (___ | |__  | |__) || |__) | |__) | |  | | |__    | | | |    | |__  | (___
 | | | |  | |\___ \|  __| |  _  / |  ___/|  _  /| |  | |  __|   | | | |    |  __|  \___ \
 _| |_| |__| |____) | |____| | \ \ | |    | | \ \| |__| | |     _| |_| |____| |____ ____) |
 |_____|\____/|_____/|______|_|  \_\|_|    |_|  \_\\____/|_|    |_____|______|______|_____/

 This file contains the database schema for user-related tables:
 - user_settings: Stores private user information
 - user_profiles: Stores public user profile information
 - user_roles: Manages user roles within the application
 - user_application_settings: User application settings generated by the application

 These tables form the foundation of the user management system in our application.
 */
CREATE TABLE IF NOT EXISTS "public"."user_profiles" (
  "id" "uuid" PRIMARY KEY NOT NULL REFERENCES "auth"."users"("id") ON DELETE CASCADE,
  "full_name" character varying,
  "avatar_url" character varying,
  "created_at" timestamp WITH time zone DEFAULT "now"() NOT NULL
);
COMMENT ON TABLE "public"."user_profiles" IS 'Stores public user profile information including full name, avatar URL, and creation timestamp.';

ALTER TABLE "public"."user_profiles" OWNER TO "postgres";
ALTER TABLE "public"."user_profiles" ENABLE ROW LEVEL SECURITY;


CREATE TABLE IF NOT EXISTS "public"."user_settings" (
  "id" "uuid" PRIMARY KEY NOT NULL REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE,
  "default_workspace" "uuid"
);
COMMENT ON TABLE "public"."user_settings" IS 'Stores user settings including the default organization.';

ALTER TABLE "public"."user_settings" OWNER TO "postgres";
ALTER TABLE "public"."user_settings" ENABLE ROW LEVEL SECURITY;

CREATE INDEX "idx_user_settings_default_workspace" ON "public"."user_settings" ("default_workspace");

CREATE TABLE IF NOT EXISTS "public"."user_application_settings" (
  "id" "uuid" PRIMARY KEY NOT NULL REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE,
  "email_readonly" character varying NOT NULL -- This mirrors the auth.users table email column for convenience purposes as it makes joining tables in the public schema easier and can be queried safely via supabase.
);
COMMENT ON TABLE "public"."user_application_settings" IS 'These settings are updated by the application. Do not use this table to update the user email.';

ALTER TABLE "public"."user_application_settings" OWNER TO "postgres";
ALTER TABLE "public"."user_application_settings" ENABLE ROW LEVEL SECURITY;

CREATE INDEX "idx_user_application_settings_email_readonly" ON "public"."user_application_settings" ("email_readonly");

CREATE TABLE IF NOT EXISTS "public"."user_roles" (
  "id" UUID PRIMARY KEY DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
  "user_id" UUID NOT NULL REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE,
  "role" "public"."app_role" NOT NULL
);
REVOKE ALL ON TABLE "public"."user_roles"
FROM "authenticated",
  "anon",
  "public";
GRANT ALL ON TABLE "public"."user_roles" TO "supabase_auth_admin";

COMMENT ON TABLE "public"."user_roles" IS 'Application roles for each user. To make a user an admin, just set this table role to "admin" for that user. And ask the user to logout and login to see the change.';


ALTER TABLE "public"."user_roles"
ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");

COMMENT ON TABLE "public"."user_roles" IS 'Application roles for each user.';
ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;


CREATE INDEX "idx_user_roles_user_id" ON "public"."user_roles" ("user_id");

CREATE TABLE IF NOT EXISTS "public"."user_api_keys" (
  "key_id" "text" PRIMARY KEY NOT NULL,
  "masked_key" "text" NOT NULL,
  "created_at" timestamp WITH time zone DEFAULT "now"() NOT NULL,
  "user_id" "uuid" NOT NULL REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE,
  "expires_at" timestamp WITH time zone,
  "is_revoked" boolean DEFAULT false NOT NULL
);
COMMENT ON TABLE "public"."user_api_keys" IS 'API keys for each user.';

ALTER TABLE "public"."user_api_keys" OWNER TO "postgres";
ALTER TABLE "public"."user_api_keys" ENABLE ROW LEVEL SECURITY;

CREATE INDEX "idx_user_api_keys_user_id" ON "public"."user_api_keys" ("user_id");


CREATE TABLE IF NOT EXISTS "public"."user_notifications" (
  "id" "uuid" PRIMARY KEY DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
  "user_id" "uuid" NOT NULL REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE,
  "is_read" boolean DEFAULT false NOT NULL,
  "is_seen" boolean DEFAULT false NOT NULL,
  "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
  "created_at" timestamp WITH time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "updated_at" timestamp WITH time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);
COMMENT ON TABLE "public"."user_notifications" IS 'User notifications including the payload, read status, and creation timestamp.';

ALTER TABLE "public"."user_notifications" OWNER TO "postgres";
ALTER TABLE "public"."user_notifications" ENABLE ROW LEVEL SECURITY;
CREATE INDEX "idx_user_notifications_user_id" ON "public"."user_notifications" ("user_id");

ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";

ALTER PUBLICATION "supabase_realtime"
ADD TABLE ONLY "public"."user_notifications";

CREATE TABLE IF NOT EXISTS "public"."account_delete_tokens" (
  "token" "uuid" PRIMARY KEY DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
  "user_id" "uuid" NOT NULL REFERENCES "public"."user_profiles"("id") ON DELETE CASCADE
);
COMMENT ON TABLE "public"."account_delete_tokens" IS 'Tokens for account deletion requests.';

ALTER TABLE "public"."account_delete_tokens" OWNER TO "postgres";
ALTER TABLE "public"."account_delete_tokens" ENABLE ROW LEVEL SECURITY;
CREATE INDEX "idx_account_delete_tokens_user_id" ON "public"."account_delete_tokens" ("user_id");


CREATE POLICY "All authenticated users can request deletion" ON "public"."account_delete_tokens" FOR
INSERT TO "authenticated" WITH CHECK (TRUE);


-- Row Level Security (RLS) policies
---------------------------------------------------------------------------
-- These policies control access to the tables based on the user's role and
-- permissions. They ensure data privacy and security at the database level.
---------------------------------------------------------------------------
-- User Profiles RLS
CREATE POLICY "Everyone can view user profile" ON "public"."user_profiles" FOR
SELECT TO "authenticated" USING (TRUE);

CREATE POLICY "Only the own user can update it" ON "public"."user_profiles" FOR
UPDATE TO "authenticated" USING (
    (
      (
        SELECT auth.uid()
      ) = "id"
    )
  );

-- User roles RLS
CREATE POLICY "All supabase auth admin can view" ON "public"."user_roles" FOR
SELECT TO "supabase_auth_admin" USING (TRUE);



-- User Application Settings RLS
CREATE POLICY "Users can view their own application settings" ON "public"."user_application_settings" FOR
SELECT TO authenticated USING (
    (
      SELECT auth.uid()
    ) = "id"
  );

-- User Settings RLS
CREATE POLICY "Users can view their own settings" ON "public"."user_settings" FOR
SELECT TO authenticated USING (
    (
      SELECT auth.uid()
    ) = "id"
  );

CREATE POLICY "Users can update their own settings" ON "public"."user_settings" FOR
UPDATE TO authenticated USING (
    (
      SELECT auth.uid()
    ) = "id"
  );



-- User API Keys RLS
CREATE POLICY "User can select their own keys" ON "public"."user_api_keys" FOR
SELECT USING (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );


CREATE POLICY "User can update their own keys" ON "public"."user_api_keys" FOR
UPDATE USING (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  ) WITH CHECK (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );
-- User Notifications RLS
CREATE POLICY "any_user_can_create_notification" ON "public"."user_notifications" FOR
INSERT TO "authenticated" WITH CHECK (TRUE);



CREATE POLICY "only_user_can_delete_their_notification" ON "public"."user_notifications" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT "auth"."uid"() AS "uid"
    ) = "user_id"
  )
);

CREATE POLICY "only_user_can_read_their_own_notification" ON "public"."user_notifications" FOR
SELECT TO "authenticated" USING (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "only_user_can_update_their_notification" ON "public"."user_notifications" FOR
UPDATE TO "authenticated" USING (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "Users can update their own notifications" ON "public"."user_notifications" FOR
UPDATE TO authenticated USING (
    (
      SELECT "auth"."uid"() AS "uid"
    ) = user_id
  );

-- Account Delete Tokens RLS
CREATE POLICY "User can insert their own keys" ON "public"."user_api_keys" FOR
INSERT WITH CHECK (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );


CREATE POLICY "User can only delete their own deletion token" ON "public"."account_delete_tokens" FOR DELETE TO "authenticated" USING (
  (
    (
      SELECT "auth"."uid"() AS "uid"
    ) = "user_id"
  )
);

CREATE POLICY "User can only read their own deletion token" ON "public"."account_delete_tokens" FOR
SELECT TO "authenticated" USING (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );

CREATE POLICY "User can only update their own deletion token" ON "public"."account_delete_tokens" FOR
UPDATE TO "authenticated" USING (
    (
      (
        SELECT "auth"."uid"() AS "uid"
      ) = "user_id"
    )
  );
